<?xml version="1.0" encoding="UTF-8"?>
<section name="Workbench">
	<section name="org.eclipse.ui.texteditor.FindReplaceDialog">
		<item value="&#x0A;/*&#x0A; * Daniel DelyMcShane&#x0A; * CS486&#x0A; * HW1: Coin-Collecting Problem&#x0A; */&#x0A;&#x0A;import java.io.File;&#x0A;import java.io.FileNotFoundException;&#x0A;import java.util.Scanner;&#x0A;import java.util.Random;&#x0A;&#x0A;public class CoinCollector {&#x0A;&#x0A;&#x09;public static int counter = 0;&#x0A;&#x09;public static void main(String[] args) throws FileNotFoundException {&#x0A;&#x0A;&#x09;&#x09;// read map from file for testing&#x0A;&#x09;&#x09;double[][] map = new double[6][7];&#x0A;&#x09;&#x09;Scanner s = new Scanner(new File(&quot;map.txt&quot;));&#x0A;&#x09;&#x09;for (int i = 0; i &lt; map.length; i++) {&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; map[i].length; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;map[i][j] = s.nextInt();&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;// get result of efficient algorithm for max coins&#x0A;&#x09;&#x09;double result = maxCoins(map);&#x0A;&#x09;&#x09;System.out.println(&quot;Efficient algorithm: &quot; + result);&#x0A;&#x09;&#x09;s.close();&#x0A;&#x0A;&#x09;&#x09; map = generateRandomMap(6, 7);&#x0A;&#x09;&#x09; maxCoins(map);&#x0A;&#x09;&#x09; maxValue(map);&#x0A;&#x09;&#x09; &#x0A;&#x09;&#x09; printMap(map);&#x0A;&#x09;&#x09;&#x09;System.out.println(&quot;GREEDY COIN VALUE:  &quot; + greedyMaxValue(map, map.length-1, map[0].length-1));&#x0A;&#x09;&#x09;&#x09;System.out.println(&quot;GREEDY COIN COUNTER:  &quot; + greedyMaxCoin(map, map.length-1, map[0].length-1));&#x0A;&#x09;&#x09;&#x09;&#x0A;&#x09;&#x09;&#x09;printMap(map);&#x0A;&#x0A;&#x0A;&#x0A;&#x0A;&#x09;&#x09;// printMap(genMap);&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// utility method to print out map&#x0A;&#x09;public static void printMap(double[][] map) {&#x0A;&#x09;&#x09;// print out map&#x0A;&#x09;&#x09;for (int i = 0; i &lt; map.length; i++) {&#x0A;&#x09;&#x09;&#x09;System.out.print(&quot;\t\tRow &quot; + i + &quot;: &quot;);&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; map[i].length; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.print(map[i][j] + &quot;|&quot;);&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;System.out.println();&#x0A;&#x09;&#x09;&#x09;// System.out.println(&quot;\t\t ----------------------------&quot;);&#x0A;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// efficient algorithm to determine the max number of coins that can be&#x0A;&#x09;// picked up&#x0A;&#x09;public static double maxCoins(double[][] coins) {&#x0A;&#x0A;&#x09;&#x09;int n = coins.length;&#x0A;&#x09;&#x09;int m = coins[0].length;&#x0A;&#x09;&#x09;// initialize result matrix to 0&#x0A;&#x09;&#x09;double[][] result = new double[n][m];&#x0A;&#x0A;&#x09;&#x09;// if first is a coin add 1, otherwise leave as 0&#x0A;&#x09;&#x09;if (coins[1][1] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;result[1][1] = 1;&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;// set first row&#x0A;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;if (coins[1][j] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1] + 1;&#x0A;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;for (int i = 2; i &lt; n; i++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;// set column i&#x0A;&#x09;&#x09;&#x09;if (coins[i][1] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1] + 1;&#x0A;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// get value to above and to left&#x0A;&#x09;&#x09;&#x09;&#x09;double up = coins[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;double left = coins[i][j - 1];&#x0A;&#x09;&#x09;&#x09;&#x09;boolean addFlag = false;&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// if coin in current slot set add flag&#x0A;&#x09;&#x09;&#x09;&#x09;if (coins[i][j] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;addFlag = true;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// if slot above has more coins so far use that&#x0A;&#x09;&#x09;&#x09;&#x09;if (up &gt; left) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;if (addFlag) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j] + 1;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;// otherwise either the left has a greater value. or netieh has&#x0A;&#x09;&#x09;&#x09;&#x09;// a value&#x0A;&#x09;&#x09;&#x09;&#x09;else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;// addFlag was set from left add 1&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;if (addFlag) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i][j - 1] + 1;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// if the slot to the left is greater than the one above&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// use that&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;if (result[i][j - 1] &gt; result[i - 1][j]) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i][j - 1];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// otherwise they&apos;re both 1 or 0 so use the slot to&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// the left&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// result[i][j] = Math.max(result[i - 1][j] + coins[i][j],&#x0A;&#x09;&#x09;&#x09;&#x09;// result[i][j - 1] + coins[i][j]);&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;/*&#x0A;&#x09;&#x09;System.out.println(&quot;Input map:&quot;);&#x0A;&#x09;&#x09;printMap(coins);&#x0A;&#x09;&#x09;System.out.println(&quot;\n\n\n&quot;);&#x0A;&#x09;&#x09;System.out.println(&quot;Result Map: &quot;);&#x0A;&#x09;&#x09;printMap(result);&#x0A;&#x0A;*/&#x0A;&#x09;&#x09;return result[n - 1][m - 1];&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// efficient algorithm to determine the maximum value of coins that can be&#x0A;&#x09;// picked up&#x0A;&#x09;public static double maxValue(double[][] coins) {&#x0A;&#x0A;&#x09;&#x09;int n = coins.length;&#x0A;&#x09;&#x09;int m = coins[0].length;&#x0A;&#x09;&#x09;// initialize result matrix to 0&#x0A;&#x09;&#x09;double[][] result = new double[n][m];&#x0A;&#x09;&#x09;result[1][1] = coins[1][1];&#x0A;&#x0A;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1] + coins[1][j];&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;for (int i = 2; i &lt; n; i++) {&#x0A;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1] + coins[i][1];&#x0A;&#x0A;&#x09;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][j] = Math.max(result[i - 1][j] + coins[i][j], result[i][j - 1] + coins[i][j]);&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;/*&#x0A;&#x09;&#x09;System.out.println(&quot;Input map:&quot;);&#x0A;&#x09;&#x09;printMap(coins);&#x0A;&#x09;&#x09;System.out.println(&quot;\n\n\n&quot;);&#x0A;&#x09;&#x09;System.out.println(&quot;Result Map: &quot;);&#x0A;&#x09;&#x09;printMap(result);&#x0A;&#x09;&#x09;*/&#x0A;&#x0A;&#x09;&#x09;return result[n - 1][m - 1];&#x0A;&#x09;}&#x0A;&#x0A;&#x09;public static double[][] generateRandomMap(int rows, int columns) {&#x0A;&#x09;&#x09;double[][] map = new double[rows][columns];&#x0A;&#x0A;&#x09;&#x09;// values to be used in map, add extra zeroes to prevent flooding map&#x0A;&#x09;&#x09;// with coins and easy to debug&#x0A;&#x09;&#x09;double[] values = { 0, 0, 0, 0, .5, 1, 2, 5 };&#x0A;&#x0A;&#x09;&#x09;Random rand = new Random();&#x0A;&#x0A;&#x09;&#x09;for (int i = 0; i &lt; rows; i++) {&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; columns; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;map[i][j] = values[rand.nextInt(8)];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;return map;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/*&#x0A;&#x09;public static double greedyMaxCoin(double[][] coins, int row, int column){&#x0A;&#x09;&#x09;&#x0A;&#x09;&#x09;if(row == 0 || column == 0)&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;return 0;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;else&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;if(coins[row][column] &gt; 0)&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x0A;&#x09;&#x09;&#x09;&#x09;return 1 + Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;else&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;counter++;&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.println(&quot;COUNTER:  &quot; + counter);&#x0A;&#x09;&#x09;&#x09;return greedyMaxCoin(coins, row-1, column) + greedyMaxCoin(coins, row, column - 1);&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x0A;&#x09;}&#x0A;&#x09; */&#x0A;&#x09;&#x0A;&#x09;public static double greedyMaxCoin(double[][] coins, int row, int column){&#x0A;&#x09;&#x09;&#x0A;&#x09;&#x09;//base case: return 0 &#x0A;&#x09;&#x09;if(row == 0 || column == 0)&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;return 0;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;else&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;//if the current slot has a coin in it add 1 and call the max functionon both possible directions&#x0A;&#x09;&#x09;&#x09;if(coins[row][column] &gt; 0)&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.println(&quot;COUNTER PING&quot;);&#x0A;&#x09;&#x09;&#x09;&#x09;//System.out.println(&quot;row: &quot; + row + &quot;column: &quot; + column);&#x0A;&#x09;&#x09;&#x09;&#x09;return 1 + Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;//otherwise just return the max of both previous paths&#x0A;&#x09;&#x09;&#x09;else&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;return Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;//System.out.println(Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1)));&#x0A;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;&#x09;&#x0A;public static double greedyMaxValue(double[][] coins, int row, int column){&#x0A;&#x09;&#x09;&#x0A;&#x09;&#x09;//base case: return 0 &#x0A;&#x09;&#x09;if(row == 0 || column == 0)&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;return 0;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;else&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;//if the current slot has a coin in it add 1 and call the max functionon both possible directions&#x0A;&#x09;&#x09;&#x09;if(coins[row][column] &gt; 0)&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.println(&quot;VALUE PING&quot;);&#x0A;&#x09;&#x09;&#x09;&#x09;return coins[row][column] + Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;//otherwise just return the max of both previous paths&#x0A;&#x09;&#x09;&#x09;else&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;return Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;//System.out.println(Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1)));&#x0A;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;&#x09;&#x0A;}" key="selection"/>
		<list key="findhistory">
			<item value="&#x0A;/*&#x0A; * Daniel DelyMcShane&#x0A; * CS486&#x0A; * HW1: Coin-Collecting Problem&#x0A; */&#x0A;&#x0A;import java.io.File;&#x0A;import java.io.FileNotFoundException;&#x0A;import java.util.Scanner;&#x0A;import java.util.Random;&#x0A;&#x0A;public class CoinCollector {&#x0A;&#x0A;&#x09;public static int counter = 0;&#x0A;&#x09;public static void main(String[] args) throws FileNotFoundException {&#x0A;&#x0A;&#x09;&#x09;// read map from file for testing&#x0A;&#x09;&#x09;double[][] map = new double[6][7];&#x0A;&#x09;&#x09;Scanner s = new Scanner(new File(&quot;map.txt&quot;));&#x0A;&#x09;&#x09;for (int i = 0; i &lt; map.length; i++) {&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; map[i].length; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;map[i][j] = s.nextInt();&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;// get result of efficient algorithm for max coins&#x0A;&#x09;&#x09;double result = maxCoins(map);&#x0A;&#x09;&#x09;System.out.println(&quot;Efficient algorithm: &quot; + result);&#x0A;&#x09;&#x09;s.close();&#x0A;&#x0A;&#x09;&#x09; map = generateRandomMap(6, 7);&#x0A;&#x09;&#x09; maxCoins(map);&#x0A;&#x09;&#x09; maxValue(map);&#x0A;&#x09;&#x09; &#x0A;&#x09;&#x09; printMap(map);&#x0A;&#x09;&#x09;&#x09;System.out.println(&quot;GREEDY COIN VALUE:  &quot; + greedyMaxValue(map, map.length-1, map[0].length-1));&#x0A;&#x09;&#x09;&#x09;System.out.println(&quot;GREEDY COIN COUNTER:  &quot; + greedyMaxCoin(map, map.length-1, map[0].length-1));&#x0A;&#x09;&#x09;&#x09;&#x0A;&#x09;&#x09;&#x09;printMap(map);&#x0A;&#x0A;&#x0A;&#x0A;&#x0A;&#x09;&#x09;// printMap(genMap);&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// utility method to print out map&#x0A;&#x09;public static void printMap(double[][] map) {&#x0A;&#x09;&#x09;// print out map&#x0A;&#x09;&#x09;for (int i = 0; i &lt; map.length; i++) {&#x0A;&#x09;&#x09;&#x09;System.out.print(&quot;\t\tRow &quot; + i + &quot;: &quot;);&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; map[i].length; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.print(map[i][j] + &quot;|&quot;);&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;System.out.println();&#x0A;&#x09;&#x09;&#x09;// System.out.println(&quot;\t\t ----------------------------&quot;);&#x0A;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// efficient algorithm to determine the max number of coins that can be&#x0A;&#x09;// picked up&#x0A;&#x09;public static double maxCoins(double[][] coins) {&#x0A;&#x0A;&#x09;&#x09;int n = coins.length;&#x0A;&#x09;&#x09;int m = coins[0].length;&#x0A;&#x09;&#x09;// initialize result matrix to 0&#x0A;&#x09;&#x09;double[][] result = new double[n][m];&#x0A;&#x0A;&#x09;&#x09;// if first is a coin add 1, otherwise leave as 0&#x0A;&#x09;&#x09;if (coins[1][1] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;result[1][1] = 1;&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;// set first row&#x0A;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;if (coins[1][j] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1] + 1;&#x0A;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;for (int i = 2; i &lt; n; i++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;// set column i&#x0A;&#x09;&#x09;&#x09;if (coins[i][1] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1] + 1;&#x0A;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// get value to above and to left&#x0A;&#x09;&#x09;&#x09;&#x09;double up = coins[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;double left = coins[i][j - 1];&#x0A;&#x09;&#x09;&#x09;&#x09;boolean addFlag = false;&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// if coin in current slot set add flag&#x0A;&#x09;&#x09;&#x09;&#x09;if (coins[i][j] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;addFlag = true;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// if slot above has more coins so far use that&#x0A;&#x09;&#x09;&#x09;&#x09;if (up &gt; left) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;if (addFlag) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j] + 1;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;// otherwise either the left has a greater value. or netieh has&#x0A;&#x09;&#x09;&#x09;&#x09;// a value&#x0A;&#x09;&#x09;&#x09;&#x09;else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;// addFlag was set from left add 1&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;if (addFlag) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i][j - 1] + 1;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// if the slot to the left is greater than the one above&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// use that&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;if (result[i][j - 1] &gt; result[i - 1][j]) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i][j - 1];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// otherwise they&apos;re both 1 or 0 so use the slot to&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// the left&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// result[i][j] = Math.max(result[i - 1][j] + coins[i][j],&#x0A;&#x09;&#x09;&#x09;&#x09;// result[i][j - 1] + coins[i][j]);&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;/*&#x0A;&#x09;&#x09;System.out.println(&quot;Input map:&quot;);&#x0A;&#x09;&#x09;printMap(coins);&#x0A;&#x09;&#x09;System.out.println(&quot;\n\n\n&quot;);&#x0A;&#x09;&#x09;System.out.println(&quot;Result Map: &quot;);&#x0A;&#x09;&#x09;printMap(result);&#x0A;&#x0A;*/&#x0A;&#x09;&#x09;return result[n - 1][m - 1];&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// efficient algorithm to determine the maximum value of coins that can be&#x0A;&#x09;// picked up&#x0A;&#x09;public static double maxValue(double[][] coins) {&#x0A;&#x0A;&#x09;&#x09;int n = coins.length;&#x0A;&#x09;&#x09;int m = coins[0].length;&#x0A;&#x09;&#x09;// initialize result matrix to 0&#x0A;&#x09;&#x09;double[][] result = new double[n][m];&#x0A;&#x09;&#x09;result[1][1] = coins[1][1];&#x0A;&#x0A;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1] + coins[1][j];&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;for (int i = 2; i &lt; n; i++) {&#x0A;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1] + coins[i][1];&#x0A;&#x0A;&#x09;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][j] = Math.max(result[i - 1][j] + coins[i][j], result[i][j - 1] + coins[i][j]);&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;/*&#x0A;&#x09;&#x09;System.out.println(&quot;Input map:&quot;);&#x0A;&#x09;&#x09;printMap(coins);&#x0A;&#x09;&#x09;System.out.println(&quot;\n\n\n&quot;);&#x0A;&#x09;&#x09;System.out.println(&quot;Result Map: &quot;);&#x0A;&#x09;&#x09;printMap(result);&#x0A;&#x09;&#x09;*/&#x0A;&#x0A;&#x09;&#x09;return result[n - 1][m - 1];&#x0A;&#x09;}&#x0A;&#x0A;&#x09;public static double[][] generateRandomMap(int rows, int columns) {&#x0A;&#x09;&#x09;double[][] map = new double[rows][columns];&#x0A;&#x0A;&#x09;&#x09;// values to be used in map, add extra zeroes to prevent flooding map&#x0A;&#x09;&#x09;// with coins and easy to debug&#x0A;&#x09;&#x09;double[] values = { 0, 0, 0, 0, .5, 1, 2, 5 };&#x0A;&#x0A;&#x09;&#x09;Random rand = new Random();&#x0A;&#x0A;&#x09;&#x09;for (int i = 0; i &lt; rows; i++) {&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; columns; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;map[i][j] = values[rand.nextInt(8)];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;return map;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;/*&#x0A;&#x09;public static double greedyMaxCoin(double[][] coins, int row, int column){&#x0A;&#x09;&#x09;&#x0A;&#x09;&#x09;if(row == 0 || column == 0)&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;return 0;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;else&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;if(coins[row][column] &gt; 0)&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x0A;&#x09;&#x09;&#x09;&#x09;return 1 + Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;else&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;counter++;&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.println(&quot;COUNTER:  &quot; + counter);&#x0A;&#x09;&#x09;&#x09;return greedyMaxCoin(coins, row-1, column) + greedyMaxCoin(coins, row, column - 1);&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x0A;&#x09;}&#x0A;&#x09; */&#x0A;&#x09;&#x0A;&#x09;public static double greedyMaxCoin(double[][] coins, int row, int column){&#x0A;&#x09;&#x09;&#x0A;&#x09;&#x09;//base case: return 0 &#x0A;&#x09;&#x09;if(row == 0 || column == 0)&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;return 0;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;else&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;//if the current slot has a coin in it add 1 and call the max functionon both possible directions&#x0A;&#x09;&#x09;&#x09;if(coins[row][column] &gt; 0)&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.println(&quot;COUNTER PING&quot;);&#x0A;&#x09;&#x09;&#x09;&#x09;//System.out.println(&quot;row: &quot; + row + &quot;column: &quot; + column);&#x0A;&#x09;&#x09;&#x09;&#x09;return 1 + Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;//otherwise just return the max of both previous paths&#x0A;&#x09;&#x09;&#x09;else&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;return Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;//System.out.println(Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1)));&#x0A;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;&#x09;&#x0A;public static double greedyMaxValue(double[][] coins, int row, int column){&#x0A;&#x09;&#x09;&#x0A;&#x09;&#x09;//base case: return 0 &#x0A;&#x09;&#x09;if(row == 0 || column == 0)&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;return 0;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;else&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;//if the current slot has a coin in it add 1 and call the max functionon both possible directions&#x0A;&#x09;&#x09;&#x09;if(coins[row][column] &gt; 0)&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.println(&quot;VALUE PING&quot;);&#x0A;&#x09;&#x09;&#x09;&#x09;return coins[row][column] + Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;//otherwise just return the max of both previous paths&#x0A;&#x09;&#x09;&#x09;else&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;return Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1));&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;//System.out.println(Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1)));&#x0A;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;&#x09;&#x0A;}"/>
			<item value="&#x0A;/*&#x0A; * Daniel DelyMcShane&#x0A; * CS486&#x0A; * HW1: Coin-Collecting Problem&#x0A; */&#x0A;&#x0A;import java.io.File;&#x0A;import java.io.FileNotFoundException;&#x0A;import java.util.Scanner;&#x0A;import java.util.Random;&#x0A;&#x0A;public class CoinCollector {&#x0A;&#x0A;&#x09;public static int counter = 0;&#x0A;&#x09;public static void main(String[] args) throws FileNotFoundException {&#x0A;&#x0A;&#x09;&#x09;// read map from file for testing&#x0A;&#x09;&#x09;double[][] map = new double[6][7];&#x0A;&#x09;&#x09;Scanner s = new Scanner(new File(&quot;map.txt&quot;));&#x0A;&#x09;&#x09;for (int i = 0; i &lt; map.length; i++) {&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; map[i].length; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;map[i][j] = s.nextInt();&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;// get result of efficient algorithm for max coins&#x0A;&#x09;&#x09;double result = maxCoins(map);&#x0A;&#x09;&#x09;System.out.println(&quot;Efficient algorithm: &quot; + result);&#x0A;&#x09;&#x09;s.close();&#x0A;&#x0A;&#x09;&#x09; //map = generateRandomMap(6, 7);&#x0A;&#x09;&#x09; //maxCoins(map);&#x0A;&#x09;&#x09; //maxValue(map);&#x0A;&#x09;&#x09; &#x0A;&#x09;&#x09;&#x09;System.out.println(&quot;GREEDY:  &quot; + greedyMaxCoin(map, map.length-1, map[0].length-1));&#x0A;&#x0A;&#x0A;&#x0A;&#x09;&#x09;// printMap(genMap);&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// utility method to print out map&#x0A;&#x09;public static void printMap(double[][] map) {&#x0A;&#x09;&#x09;// print out map&#x0A;&#x09;&#x09;for (int i = 0; i &lt; map.length; i++) {&#x0A;&#x09;&#x09;&#x09;System.out.print(&quot;\t\tRow &quot; + i + &quot;: &quot;);&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; map[i].length; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.print(map[i][j] + &quot;|&quot;);&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;System.out.println();&#x0A;&#x09;&#x09;&#x09;// System.out.println(&quot;\t\t ----------------------------&quot;);&#x0A;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// efficient algorithm to determine the max number of coins that can be&#x0A;&#x09;// picked up&#x0A;&#x09;public static double maxCoins(double[][] coins) {&#x0A;&#x0A;&#x09;&#x09;int n = coins.length;&#x0A;&#x09;&#x09;int m = coins[0].length;&#x0A;&#x09;&#x09;// initialize result matrix to 0&#x0A;&#x09;&#x09;double[][] result = new double[n][m];&#x0A;&#x0A;&#x09;&#x09;// if first is a coin add 1, otherwise leave as 0&#x0A;&#x09;&#x09;if (coins[1][1] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;result[1][1] = 1;&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;// set first row&#x0A;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;if (coins[1][j] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1] + 1;&#x0A;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;for (int i = 2; i &lt; n; i++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;// set column i&#x0A;&#x09;&#x09;&#x09;if (coins[i][1] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1] + 1;&#x0A;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// get value to above and to left&#x0A;&#x09;&#x09;&#x09;&#x09;double up = coins[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;double left = coins[i][j - 1];&#x0A;&#x09;&#x09;&#x09;&#x09;boolean addFlag = false;&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// if coin in current slot set add flag&#x0A;&#x09;&#x09;&#x09;&#x09;if (coins[i][j] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;addFlag = true;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// if slot above has more coins so far use that&#x0A;&#x09;&#x09;&#x09;&#x09;if (up &gt; left) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;if (addFlag) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j] + 1;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;// otherwise either the left has a greater value. or netieh has&#x0A;&#x09;&#x09;&#x09;&#x09;// a value&#x0A;&#x09;&#x09;&#x09;&#x09;else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;// addFlag was set from left add 1&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;if (addFlag) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i][j - 1] + 1;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// if the slot to the left is greater than the one above&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// use that&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;if (result[i][j - 1] &gt; result[i - 1][j]) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i][j - 1];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// otherwise they&apos;re both 1 or 0 so use the slot to&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// the left&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// result[i][j] = Math.max(result[i - 1][j] + coins[i][j],&#x0A;&#x09;&#x09;&#x09;&#x09;// result[i][j - 1] + coins[i][j]);&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;System.out.println(&quot;Input map:&quot;);&#x0A;&#x09;&#x09;printMap(coins);&#x0A;&#x09;&#x09;System.out.println(&quot;\n\n\n&quot;);&#x0A;&#x09;&#x09;System.out.println(&quot;Result Map: &quot;);&#x0A;&#x09;&#x09;printMap(result);&#x0A;&#x0A;&#x09;&#x09;return result[n - 1][m - 1];&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// efficient algorithm to determine the maximum value of coins that can be&#x0A;&#x09;// picked up&#x0A;&#x09;public static double maxValue(double[][] coins) {&#x0A;&#x0A;&#x09;&#x09;int n = coins.length;&#x0A;&#x09;&#x09;int m = coins[0].length;&#x0A;&#x09;&#x09;// initialize result matrix to 0&#x0A;&#x09;&#x09;double[][] result = new double[n][m];&#x0A;&#x09;&#x09;result[1][1] = coins[1][1];&#x0A;&#x0A;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1] + coins[1][j];&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;for (int i = 2; i &lt; n; i++) {&#x0A;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1] + coins[i][1];&#x0A;&#x0A;&#x09;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][j] = Math.max(result[i - 1][j] + coins[i][j], result[i][j - 1] + coins[i][j]);&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;System.out.println(&quot;Input map:&quot;);&#x0A;&#x09;&#x09;printMap(coins);&#x0A;&#x09;&#x09;System.out.println(&quot;\n\n\n&quot;);&#x0A;&#x09;&#x09;System.out.println(&quot;Result Map: &quot;);&#x0A;&#x09;&#x09;printMap(result);&#x0A;&#x0A;&#x09;&#x09;return result[n - 1][m - 1];&#x0A;&#x09;}&#x0A;&#x0A;&#x09;public static double[][] generateRandomMap(int rows, int columns) {&#x0A;&#x09;&#x09;double[][] map = new double[rows][columns];&#x0A;&#x0A;&#x09;&#x09;// values to be used in map, add extra zeroes to prevent flooding map&#x0A;&#x09;&#x09;// with coins and easy to debug&#x0A;&#x09;&#x09;double[] values = { 0, 0, 0, 0, .5, 1, 2, 5 };&#x0A;&#x0A;&#x09;&#x09;Random rand = new Random();&#x0A;&#x0A;&#x09;&#x09;for (int i = 0; i &lt; rows; i++) {&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; columns; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;map[i][j] = values[rand.nextInt(8)];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;return map;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;public static double greedyMaxCoin(double[][] coins, int row, int column){&#x0A;&#x09;&#x09;&#x0A;&#x09;&#x09;if(row == 0 || column == 0)&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;return 0;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;else&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;if(coins[row][column] &gt; 0)&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x0A;&#x09;&#x09;&#x09;&#x09;return 1 + Math.max(greedyMaxCoin(coins, row-1, column), greedyMaxCoin(coins, row, column- 1))_;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;else&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;counter++;&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.println(&quot;COUNTER:  &quot; + counter);&#x0A;&#x09;&#x09;&#x09;return greedyMaxCoin(coins, row-1, column) + greedyMaxCoin(coins, row, column - 1);&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x0A;&#x09;}&#x0A;}"/>
			<item value="&#x0A;/*&#x0A; * Daniel DelyMcShane&#x0A; * CS486&#x0A; * HW1: Coin-Collecting Problem&#x0A; */&#x0A;&#x0A;import java.io.File;&#x0A;import java.io.FileNotFoundException;&#x0A;import java.util.Scanner;&#x0A;import java.util.Random;&#x0A;&#x0A;public class CoinCollector {&#x0A;&#x0A;&#x09;public static void main(String[] args) throws FileNotFoundException {&#x0A;&#x0A;&#x09;&#x09;// read map from file for testing&#x0A;&#x09;&#x09;double[][] map = new double[6][7];&#x0A;&#x09;&#x09;Scanner s = new Scanner(new File(&quot;map.txt&quot;));&#x0A;&#x09;&#x09;for (int i = 0; i &lt; map.length; i++) {&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; map[i].length; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;map[i][j] = s.nextInt();&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;// get result of efficient algorithm for max coins&#x0A;&#x09;&#x09;double result = maxCoins(map);&#x0A;&#x09;&#x09;System.out.println(&quot;Efficient algorithm: &quot; + result);&#x0A;&#x09;&#x09;s.close();&#x0A;&#x0A;&#x09;&#x09;// map = generateRandomMap(6, 7);&#x0A;&#x09;&#x09;// maxCoins(map);&#x0A;&#x09;&#x09;// maxValue(map);&#x0A;&#x0A;&#x09;&#x09;System.out.println(&quot;GREEDY:  &quot; + greedyMaxCoin(map, map.length, map[0].length));&#x0A;&#x0A;&#x09;&#x09;// printMap(genMap);&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// utility method to print out map&#x0A;&#x09;public static void printMap(double[][] map) {&#x0A;&#x09;&#x09;// print out map&#x0A;&#x09;&#x09;for (int i = 0; i &lt; map.length; i++) {&#x0A;&#x09;&#x09;&#x09;System.out.print(&quot;\t\tRow &quot; + i + &quot;: &quot;);&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; map[i].length; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;System.out.print(map[i][j] + &quot;|&quot;);&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;System.out.println();&#x0A;&#x09;&#x09;&#x09;// System.out.println(&quot;\t\t ----------------------------&quot;);&#x0A;&#x09;&#x09;}&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// efficient algorithm to determine the max number of coins that can be&#x0A;&#x09;// picked up&#x0A;&#x09;public static double maxCoins(double[][] coins) {&#x0A;&#x0A;&#x09;&#x09;int n = coins.length;&#x0A;&#x09;&#x09;int m = coins[0].length;&#x0A;&#x09;&#x09;// initialize result matrix to 0&#x0A;&#x09;&#x09;double[][] result = new double[n][m];&#x0A;&#x0A;&#x09;&#x09;// if first is a coin add 1, otherwise leave as 0&#x0A;&#x09;&#x09;if (coins[1][1] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;result[1][1] = 1;&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;// set first row&#x0A;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;if (coins[1][j] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1] + 1;&#x0A;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;for (int i = 2; i &lt; n; i++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;// set column i&#x0A;&#x09;&#x09;&#x09;if (coins[i][1] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1] + 1;&#x0A;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// get value to above and to left&#x0A;&#x09;&#x09;&#x09;&#x09;double up = coins[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;double left = coins[i][j - 1];&#x0A;&#x09;&#x09;&#x09;&#x09;boolean addFlag = false;&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// if coin in current slot set add flag&#x0A;&#x09;&#x09;&#x09;&#x09;if (coins[i][j] &gt; 0) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;addFlag = true;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// if slot above has more coins so far use that&#x0A;&#x09;&#x09;&#x09;&#x09;if (up &gt; left) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;if (addFlag) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j] + 1;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;&#x09;// otherwise either the left has a greater value. or netieh has&#x0A;&#x09;&#x09;&#x09;&#x09;// a value&#x0A;&#x09;&#x09;&#x09;&#x09;else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;// addFlag was set from left add 1&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;if (addFlag) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i][j - 1] + 1;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// if the slot to the left is greater than the one above&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// use that&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;if (result[i][j - 1] &gt; result[i - 1][j]) {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i][j - 1];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// otherwise they&apos;re both 1 or 0 so use the slot to&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;// the left&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;} else {&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;result[i][j] = result[i - 1][j];&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;&#x09;&#x09;// result[i][j] = Math.max(result[i - 1][j] + coins[i][j],&#x0A;&#x09;&#x09;&#x09;&#x09;// result[i][j - 1] + coins[i][j]);&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;System.out.println(&quot;Input map:&quot;);&#x0A;&#x09;&#x09;printMap(coins);&#x0A;&#x09;&#x09;System.out.println(&quot;\n\n\n&quot;);&#x0A;&#x09;&#x09;System.out.println(&quot;Result Map: &quot;);&#x0A;&#x09;&#x09;printMap(result);&#x0A;&#x0A;&#x09;&#x09;return result[n - 1][m - 1];&#x0A;&#x09;}&#x0A;&#x0A;&#x09;// efficient algorithm to determine the maximum value of coins that can be&#x0A;&#x09;// picked up&#x0A;&#x09;public static double maxValue(double[][] coins) {&#x0A;&#x0A;&#x09;&#x09;int n = coins.length;&#x0A;&#x09;&#x09;int m = coins[0].length;&#x0A;&#x09;&#x09;// initialize result matrix to 0&#x0A;&#x09;&#x09;double[][] result = new double[n][m];&#x0A;&#x09;&#x09;result[1][1] = coins[1][1];&#x0A;&#x0A;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;result[1][j] = result[1][j - 1] + coins[1][j];&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;for (int i = 2; i &lt; n; i++) {&#x0A;&#x09;&#x09;&#x09;result[i][1] = result[i - 1][1] + coins[i][1];&#x0A;&#x0A;&#x09;&#x09;&#x09;for (int j = 2; j &lt; m; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;result[i][j] = Math.max(result[i - 1][j] + coins[i][j], result[i][j - 1] + coins[i][j]);&#x0A;&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;System.out.println(&quot;Input map:&quot;);&#x0A;&#x09;&#x09;printMap(coins);&#x0A;&#x09;&#x09;System.out.println(&quot;\n\n\n&quot;);&#x0A;&#x09;&#x09;System.out.println(&quot;Result Map: &quot;);&#x0A;&#x09;&#x09;printMap(result);&#x0A;&#x0A;&#x09;&#x09;return result[n - 1][m - 1];&#x0A;&#x09;}&#x0A;&#x0A;&#x09;public static double[][] generateRandomMap(int rows, int columns) {&#x0A;&#x09;&#x09;double[][] map = new double[rows][columns];&#x0A;&#x0A;&#x09;&#x09;// values to be used in map, add extra zeroes to prevent flooding map&#x0A;&#x09;&#x09;// with coins and easy to debug&#x0A;&#x09;&#x09;double[] values = { 0, 0, 0, 0, .5, 1, 2, 5 };&#x0A;&#x0A;&#x09;&#x09;Random rand = new Random();&#x0A;&#x0A;&#x09;&#x09;for (int i = 0; i &lt; rows; i++) {&#x0A;&#x09;&#x09;&#x09;for (int j = 0; j &lt; columns; j++) {&#x0A;&#x09;&#x09;&#x09;&#x09;map[i][j] = values[rand.nextInt(8)];&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x0A;&#x09;&#x09;return map;&#x0A;&#x09;}&#x0A;&#x0A;&#x09;public static double greedyMaxCoin(double[][] coins, int row, int column){&#x0A;&#x09;&#x09;&#x0A;&#x09;&#x09;if(row == coins.length || column == coins[0].length)&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;return 0;&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;else&#x0A;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;if(coins[row][column] &gt; 0)&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;return 1 + greedyMaxCoin(coins, row+1, column) + greedyMaxCoin(coins, row, column + 1)&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x09;else&#x0A;&#x09;&#x09;&#x09;{&#x0A;&#x09;&#x09;&#x09;&#x09;&#x0A;&#x09;&#x09;&#x09;&#x0A;&#x09;&#x09;&#x09;return greedyMaxCoin(coins, row+1, column) + greedyMaxCoin(coins, row, column + 1);&#x0A;&#x09;&#x09;&#x09;}&#x0A;&#x09;&#x09;}&#x0A;&#x09;&#x09;&#x0A;&#x09;}&#x0A;}"/>
		</list>
	</section>
</section>
